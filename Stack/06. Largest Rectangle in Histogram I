Given an array of integers heights representing the histogram's bar height where the width of each bar is 1, 
return the area of the largest rectangle in the histogram

//Hint: Use previous & next smaller to calculated width of the rectangle
- remember, we already have height, we need to find a width
- Use previous & next smaller to calculated width of the rectangle
-- We store indexes in the stack, not the heights[i] because we are calculating width not height
-- remember for previousSmaller out-of-bounds is -1 & for nextSmaller it is n
- Previous-smaller and next-smaller will tell us the width of the rectangle


int main()
{
    vector<int> a = {4,2,1,5,6,3,2,4,2};
    int n = a.size();
    stack<int> s;
    vector<int> ps(n);
    vector<int> ns(n);
    
    //Previous Smaller elements
    for(int i =0; i<n; i++){
        while(s.empty()==false && a[s.top()]>=a[i])
            s.pop();
        ps[i] = (s.empty())?-1: s.top();
        s.push(i);
    }
    while(s.empty()==false) s.pop();
    //Next Smaller elements
    for(int i = n-1; i>=0; i--){
        while(s.empty()==false && a[s.top()]>=a[i])
            s.pop();
        ns[i] = (s.empty())?n:s.top();
        s.push(i);
    }

    int res = 0;
    int cur = 0;
    for(int i = 0; i<n; i++){
        cur = (ns[i]-ps[i]-1)*a[i];     //This is crucial, (ns[i]-ps[i]-1) is used to calculated width & a[i] for height
        res = max(res, cur);
    }
    cout<<res;
}

--------------------------------------------------------------------------------------------------
JavaScript:
- remember, we store indexes in ps & ns and not heights[i] because we are looking for width not height (as it is already given)

var largestRectangleArea = function(heights) {
    let n = heights.length;
    let stack = [];
    let ps = [];
    let ns = [];

    for(let i = 0; i<n; i++) {
        while(stack.length && heights[i] <= heights[stack[stack.length - 1]]) {
            stack.pop();
        }
        ps[i] = stack.length ? stack[stack.length - 1] : -1; //in else we store outofbounds index
        stack.push(i);
    }

    stack = [];

    for(let i = n-1; i>=0; i--) {
        while(stack.length && heights[i]<= heights[stack[stack.length - 1]]) {
            stack.pop();
        }
        ns[i] = stack.length ? stack[stack.length - 1] : n; //in else we store outofbounds index
        stack.push(i);
    }

    let cur = 0;
    let res = 0;
    for(let i = 0; i<n; i++) {
        cur = (ns[i] - ps[i] - 1) * heights[i];
        res = Math.max(res, cur);
    }
    return res;
};
