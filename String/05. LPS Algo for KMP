//Longest Perfect Prefix Suffix;
//Example 1
Input: s = "level"
Output: "l"
lps = 0, 0, 0, 0, 1

//Example 2
Input: s = "ababac"
Output: "l"
lps = 0, 0, 1, 2, 3,0

//Idea:
- LPS array shows the no. of letters in the matching patter
- Rest all info is commented in the code



int fillLPS(string s, int *lps){
    lps[0]=0;
    int len = 0;    //length or no. of characters matching 
    int i = 1;
    while(i<s.length()){
        if(s[i]==s[len]){   //if letter match
            len++;
            lps[i]=len;
            i++;
        }
        else{
            if(len==0){     //if len has no match, again lps[i] would be zero
                lps[i]=0;
                i++;
            }
            else{
                len=lps[len-1];     //up until now there were matching letters, but now its not so len would get the previous value it held
            }
        }
    }
    return 0;
}

int main()
{
    cout<<"Hello World";
    string s = "ababacab";
    int lps[s.length()];
    fillLPS(s, lps);
    cout<<"LPS is :";
    for(int i=0; i<s.length(); i++){
        cout<<lps[i]<<" ";
    }
    return 0;
}

````````````````````````````````````````````````````````````````````
JavaScript -O(m+n)
``````````````````````````````````````````````````````````````````
// Compute LPS array for a given pattern (Knuth–Morris–Pratt preprocessing)
function computeLPS(pattern) {
  const n = pattern.length;
  const lps = new Array(n).fill(0);
  let len = 0; // length of the previous longest prefix suffix
  let i = 1;   // we start from index 1

  while (i < n) {
    if (pattern[i] === pattern[len]) {
      len++;
      lps[i] = len;
      i++;
    } else {
      if (len !== 0) {
        // fallback: try the previous smaller prefix-suffix
        len = lps[len - 1];
        // note: we do NOT increment i here
      } else {
        // no proper prefix which is suffix ends at i
        lps[i] = 0;
        i++;
      }
    }
  }

  return lps;
}

